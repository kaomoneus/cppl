//===--- HeaderGenerator.h - C++ HeaderGenerator class ----------*- C++ -*-===//
//
// Part of the C++ Levitation Project,
// under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
//  This file contains .h files generator class
//
//===----------------------------------------------------------------------===//

#ifndef LLVM_LEVITATION_HEADERGENERATOR_H
#define LLVM_LEVITATION_HEADERGENERATOR_H

#include "llvm/ADT/StringRef.h"
#include "clang/Basic/FileManager.h"
#include "clang/Levitation/Common/CreatableSingleton.h"
#include "clang/Levitation/Common/File.h"
#include "clang/Levitation/Common/Path.h"
#include "clang/Levitation/Common/SimpleLogger.h"
#include "clang/Levitation/Common/Utility.h"
#include "clang/Levitation/Driver/Dump.h"

namespace clang { namespace levitation { namespace tools {

class HeaderGenerator {
  llvm::StringRef SourcesRoot;
  llvm::StringRef OutDir;
  llvm::StringRef OutputFile;
  llvm::StringRef SourceFile;
  Twine SourceFileFullPath;
  Twine OutputFileFullPath;
  const Paths& Includes;
  const RangesVector& SkippedBytes;
  bool Verbose;
  bool DryRun;
  log::Logger &Log;

public:
  HeaderGenerator(
      llvm::StringRef SourceRoot,
      llvm::StringRef OutDir,
      llvm::StringRef OutputFile,
      const llvm::StringRef &SourceFile,
      const Paths &Includes,
      const RangesVector &SkippedBytes,
      bool Verbose,
      bool DryRun
  )
  : SourcesRoot(SourceRoot),
    OutDir(OutDir),
    OutputFile(OutputFile),
    SourceFile(SourceFile),
    Includes(Includes),
    SkippedBytes(SkippedBytes),
    Verbose(Verbose),
    DryRun(DryRun),
    Log(log::Logger::get())
  {}

  std::unique_ptr<MemoryBuffer> getSourceFileBuffer() {
    // return InputFile("$SourcesRoot/$SourceFile")
    auto InFilePath = levitation::Path::getPath<SinglePath>(
      SourcesRoot, SourceFile
    );
    auto &FM = CreatableSingleton<FileManager>::get();
    auto MemBufOrErr = FM.getBufferForFile(InFilePath);

    if (!MemBufOrErr)
      return nullptr;

    return std::move(MemBufOrErr.get());
  }

  File createOutputFile() {
    auto OutFilePath = levitation::Path::getPath<SinglePath>(
      OutDir, OutputFile
    );
    return File(OutFilePath);
  }

  void diagInFileIOIssues() {
    Log.error() << "Failed to open file '" << SourceFileFullPath << "'\n";
  }

  void diagOutFileIOIssues(File::StatusEnum Status) {
      auto &err = Log.error()
      << "Failed to open file '" << OutputFileFullPath << "': ";

      switch (Status) {
        case File::HasStreamErrors:
          err << "stream error.";
          break;
        case File::FiledToRename:
          err << "temp file created, but failed to rename.";
          break;
        case File::FailedToCreateTempFile:
          err << "failed to create temp file.";
          break;
        default:
          err << "unknown reason.";
          break;
      }
      err << "\n";
  }

  void emitHeadComment(llvm::raw_ostream &out) {
    out << "// This file is generated by C++ Levitation driver\n\n";
  }

  void emitAfterIncludesComment(llvm::raw_ostream &out) {
    out << "\n"
        << "// Below follows stripped part of source starting\n"
        << "// from user include directives."
        << "\n";
  }

  void emitIncludes(llvm::raw_ostream &out) {

    out << "// Include other generated headers current file depends on";

    for (const auto &inc : Includes) {
      out << "#include \"" << inc << "\"\n";
    }

    out << "\n";
  }

  bool execute() {
    if (Verbose)
      dump(Log.verbose());
    else if (DryRun)
      dump(Log.info());

    if (DryRun)
      return true;

    if (auto InPtr = getSourceFileBuffer()) {
      const auto &In = *InPtr;
      const char *InStart = In.getBufferStart();
      size_t InSize = In.getBufferSize();

      auto OutF = createOutputFile();
      if (auto OpenedFile = OutF.open()) {
        auto &out = OpenedFile.getOutputStream();

        emitHeadComment(out);

        emitIncludes(out);

        emitAfterIncludesComment(out);

        size_t start = 0;
        for (const auto &skippedRange : SkippedBytes) {

          size_t writeCount = skippedRange.first - start;
          assert(start + writeCount <= InSize);

          out.write(InStart + start, writeCount);

          start = skippedRange.second;
        }

        size_t writeCount = InSize - start;
        assert(start + writeCount <= In.getBufferSize());

        out.write(InStart + start, writeCount);
      }

      if (OutF.hasErrors()) {
        diagOutFileIOIssues(OutF.getStatus());
        return false;
      }
    } else {
      diagInFileIOIssues();
      return false;
    }

    return true;
  }

  void dump(llvm::raw_ostream &out) {
    DriverPhaseDump::action(
        out, OutputFile, SourceFile, Includes, "GEN HEADER", ".h"
    );
  }
};

}}}

#endif //LLVM_LEVITATION_HEADERGENERATOR_H
