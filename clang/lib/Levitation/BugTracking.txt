L-1

TITLE: Templates Specialization merging

DESCRIPTION: It is possible to produce implicit template specializations in
different places. Which could be a dependencies for same AST, and it should be
possible to merge such instantiations during dependency loading.

STATUS: Fixed
BLOCKED BY: L-6


L-2

TITLE: Add Enums support

DESCRIPTION: Enable Enums instantiation.

STATUS: Open


L-3

TITLE: Out of scope members instantiation.

DESCRIPTION: Enable scope member functions instantiations. It should work
for regular member functions and for template specializations as well.

STATUS: In progress.


L-4

TITLE: Driver support

DESCRIPTION: Enable build workflow support in driver. Driver should take on
input source root directory and build root directory and either produce set of
.o files or also link them and produce binary.

STATUS: Open


L-5

TITLE: Manual dependency import

DESCRIPTION: "Manual dependency import" feature allows user to setup
dependencies by means of import directive. Parser perhaps still should
produce whole AST. But if manual dependencies used it is not necessary to
refer other classes via "global" keyword, for the is no instantiation stage.
Manual dependencies import syntax should be as follows:
#[dependency|definition-dependency] "path-relative-to-source-root.cppl"

STATUS: Open


L-6

TITLE: ClassTemplateDecl should be instantiated.

DESCRIPTION: During instantiation we should move it
out of package namespace, or make a copy, and shadow previous
declaration. Even though ClassTemplateDecl is dependent context
itself it should belong to non-dependent namespace afterall.
Otherwise every implicit or explicit instantiaton will be
considered as dependent, due to wrong
Template->getDeclContext()->isDependentContext().
See TemplateName::isDependent.

STATUS: Fixed


L-7

TITLE: Cancelation of 'implicit methods inlining' also forces explicit inline
functions to be external.

DESCRIPTION: Current implelentation of "forcing in-line methods definition" to
be external, unless "inline" is provided explicitly works wrong.
For this case:
  struct dummy {
    inline dummy &operator<<(const char*) {}
  }
it also produces external function, ignoring "inline" specifier.

STATUS: Fixed.
