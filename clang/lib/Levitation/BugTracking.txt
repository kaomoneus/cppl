L-1

TITLE: Templates Specialization merging

DESCRIPTION: It is possible to produce implicit template specializations in
different places. Which could be a dependencies for same AST, and it should be
possible to merge such instantiations during dependency loading.

STATUS: Fixed
BLOCKED BY: L-6


L-2

TITLE: Add Enums support

DESCRIPTION: Enable Enums instantiation.

STATUS: Open


L-3

TITLE: Out of scope members instantiation.

DESCRIPTION: Enable scope member functions instantiations. It should work
for regular member functions and for template specializations as well.

STATUS: In progress.
BLOCKED-BY: L-8, L-10


L-4

TITLE: Driver support

DESCRIPTION: Enable build workflow support in driver. Driver should take on
input source root directory and build root directory and either produce set of
.o files or also link them and produce binary.

STATUS: Open


L-5

TITLE: Manual dependency import

DESCRIPTION: "Manual dependency import" feature allows user to setup
dependencies by means of import directive. Parser perhaps still should
produce whole AST. But if manual dependencies used it is not necessary to
refer other classes via "global" keyword, for the is no instantiation stage.
Manual dependencies import syntax should be as follows:
#[dependency|definition-dependency] "path-relative-to-source-root.cppl"

STATUS: Open


L-6

TITLE: ClassTemplateDecl should be instantiated.

DESCRIPTION: During instantiation we should move it
out of package namespace, or make a copy, and shadow previous
declaration. Even though ClassTemplateDecl is dependent context
itself it should belong to non-dependent namespace afterall.
Otherwise every implicit or explicit instantiaton will be
considered as dependent, due to wrong
Template->getDeclContext()->isDependentContext().
See TemplateName::isDependent.

STATUS: Fixed


L-7

TITLE: Cancelation of 'implicit methods inlining' also forces explicit inline
functions to be external.

DESCRIPTION: Current implelentation of "forcing in-line methods definition" to
be external, unless "inline" is provided explicitly works wrong.
For this case:
  struct dummy {
    inline dummy &operator<<(const char*) {}
  }
it also produces external function, ignoring "inline" specifier.

STATUS: Fixed.

L-8

TITLE: ASTReader, Support of top-level variables.

DESCRIPTION: In ReadDeclarationsOnly mode, all top level variables
should be marked as external, with omitted initialization section.

STATUS: In progress.


L-9

TITLE: Broken support for ClassTemplateSpecializationDecl

DESCRIPTION: Currently we're having crashed during codegen.

STATUS: Fixed.

L-10
TITLE: Support for out of scope member function templates
DESCRIPTION: Currently such decls are ignored during instantiation, since
it was supposed they always belong to namespace which can't be
dependent in legacy mode.

STATUS: Fixed.

L-11
TITLE: Bug, crash, when failed to read one of dependencies.
DESCRIPTION:
STATUS: Fixed.

L-12
TITLE: Bug, crash, during second load of same template specialization.
DESCRIPTION: Crashing if we use preamble as follows:
namespace std {
    struct dummy {
        template <typename T> inline std::dummy &operator<<(T)         {
            return *this;
        }
        template<> inline std::dummy &operator<<<const char *>(const char *)    };
    extern std::dummy cout;
}
STATUS: Fixed.

L-13
TITLE: Redeclaration detection improvement
DESCRIPTION:
// preamble.cpp

struct Dummy {
     template <typename T>
     inline void f() {};
  };

  extern Dummy d;

// EOF

preamble --> B --> C --> D
          `--------^

1. When we parse B, it creates implicit instantiation of Dummy::f<int>()
2. When we parse C, it also creates implicit instantiation of Dummy::f<int>()
3. When we instantiate C it already has package instantiated version of f<int>,
and it has non-instantiated version of its own f<int>. So it creates
another package-instantiated f<int>. But it could find out that we always have it in
dependencies.